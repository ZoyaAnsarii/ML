
## Create virtual envornment
* `python -m venv <abc>`
    * Windows `.\<abc>\Scripts\activate`

* Install required packages in Virtual Envornment
    * `pip install numpy pandas django`
    * install packages with **requirements.txt**
        * `pip install -r requirements.txt`
    * `pip freeze > requirements.txt` Save all pakcages names in **requirements.txt**
## Start working on Django Project
* `python -m django --version`
* Create new project 
    * `django-admin startproject <mysite>`
* now run your server
    * `python manage.py runserver`
    * `python manage.py migrate`

* Create **polls** app
    * `python manage.py startapp <polls>`
    In our poll app, weâ€™ll create two models: Question and Choice. 
    A Question has a question and a publication date. 
    A Choice has two fields: the text of the choice and a vote tally. Each Choice is associated with a Question
        * **polls/models.py** create
        ```
        from django.db import models

        class Question(models.Model):
            question_text = models.CharField(max_length=200)
            pub_date = models.DateTimeField('date published')

            def __str__(self):
                return self.question_text


        class Choice(models.Model):
            question = models.ForeignKey(Question, on_delete=models.CASCADE)
            choice_text = models.CharField(max_length=200)
            votes = models.IntegerField(default=0)
        
            def __str__(self):
                return self.choice_text

            def was_published_recently(self):
                return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
        
        ```
    Tell the project that the polls app is installed.
        * **mysite/settings.py**
        ```
        INSTALLED_APPS = [
        'polls.apps.PollsConfig',
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        ]
        ```  
        Now Django knows to include the polls app
    * `python manage.py makemigrations polls`
        * The output looks something like this:
        ```
        Migrations for 'polls':
         polls/migrations/0001_initial.py
        - Create model Question
        - Create model Choice
        ```     
    * The sqlmigrate command takes migration names and returns their SQL
        * `python manage.py sqlmigrate polls 0001`
            * The output looks something like this:
            ```
            BEGIN;
            --
            -- Create model Question
            --
            CREATE TABLE "polls_question" (
            "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            "question_text" varchar(200) NOT NULL,
            "pub_date" timestamp with time zone NOT NULL
            );
            --
            -- Create model Choice
            --
            CREATE TABLE "polls_choice" (
            "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            "choice_text" varchar(200) NOT NULL,
            "votes" integer NOT NULL,
            "question_id" bigint NOT NULL
            );
            ALTER TABLE "polls_choice"
            ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
            FOREIGN KEY ("question_id")
            REFERENCES "polls_question" ("id")
            DEFERRABLE INITIALLY DEFERRED;
            CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

            COMMIT;
            ```
        * Now, run migrate again to create those model tables in your database:
            * `python manage.py migrate`
        * Playing with the API
            * `python manage.py shell`
                
                >>> from polls.models import Choice, Question  # Import the model classes we just wrote.
                # No questions are in the system yet.
                >>> Question.objects.all()
                output: <QuerySet []>
                # Create a new Question.
                # Support for time zones is enabled in the default settings file, so
                # Django expects a datetime with tzinfo for pub_date. Use timezone.now()
                # instead of datetime.datetime.now() and it will do the right thing.
                >>> from django.utils import timezone
                >>> q = Question(question_text="What's new?", pub_date=timezone.now())

                # Save the object into the database. You have to call save() explicitly.
                >>> q.save()

                # Now it has an ID.
                >>> q.id
                `output: 1`

                # Access model field values via Python attributes.
                >>> q.question_text
                "What's new?"
                >>> q.pub_date
                datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=datetime.timezone.utc)

                # Change values by changing the attributes, then calling save().
                >>> q.question_text = "What's up?"
                >>> q.save()
                >>> Question.objects.all()
                `output: <QuerySet [<Question: What's up?>]>`
                # Django provides a rich database lookup API that's entirely driven by
                # keyword arguments.
                >>> Question.objects.filter(id=1)
                `output:<QuerySet [<Question: What's up?>]>`
                >>> Question.objects.filter(question_text__startswith='What')
                `output: <QuerySet [<Question: What's up?>]>`

                # Get the question that was published this year.
                >>> from django.utils import timezone
                >>> current_year = timezone.now().year
                >>> Question.objects.get(pub_date__year=current_year)
                `output: <Question: What's up?>`

                # Request an ID that doesn't exist, this will raise an exception.
                >>> Question.objects.get(id=2)
                ```
                output:
                Traceback (most recent call last):
                    ...
                DoesNotExist: Question matching query does not exist.
                ```

                # Lookup by a primary key is the most common case, so Django provides a
                # shortcut for primary-key exact lookups.
                # The following is identical to Question.objects.get(id=1).
                >>> Question.objects.get(pk=1)
                `output:<Question: What's up?>`

                # Make sure our custom method worked.
                >>> q = Question.objects.get(pk=1)
                >>> q.was_published_recently()
                `output: True`

                # Give the Question a couple of Choices. The create call constructs a new
                # Choice object, does the INSERT statement, adds the choice to the set
                # of available choices and returns the new Choice object. Django creates
                # a set to hold the "other side" of a ForeignKey relation
                # (e.g. a question's choice) which can be accessed via the API.
                >>> q = Question.objects.get(pk=1)

                # Display any choices from the related object set -- none so far.
                >>> q.choice_set.all()
                `output: <QuerySet []>`

                # Create three choices.
                >>> q.choice_set.create(choice_text='Not much', votes=0)
                `output: <Choice: Not much>`
                >>> q.choice_set.create(choice_text='The sky', votes=0)
                `output: <Choice: The sky>`
                >>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)

                # Choice objects have API access to their related Question objects.
                >>> c.question
                `output: <Question: What's up?>`

                # And vice versa: Question objects get access to Choice objects.
                >>> q.choice_set.all()
                `output: <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>`
                >>> q.choice_set.count()
                `output: 3`

                # The API automatically follows relationships as far as you need.
                # Use double underscores to separate relationships.
                # This works as many levels deep as you want; there's no limit.
                # Find all Choices for any question whose pub_date is in this year
                # (reusing the 'current_year' variable we created above).
                >>> Choice.objects.filter(question__pub_date__year=current_year)
                `output: <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>`

                # Let's delete one of the choices. Use delete() for that.
                >>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
                >>> c.delete()
                >>> exit() #to exit the shell
        * Creating an admin user:
            * `python manage.py createsuperuser`
            * `Username: <zoyaa>`
            * `Email address: <zoyaansari@hotmail.com>`
            * `Password: ***********` #mydjangoapp
            * `Password (again):***********`
        * Start the development server
            * `python manage.py runserver`
        * Make the poll app modifiable in the admin
            * **polls/admin.py**
        ````
        from django.contrib import admin
        from .models import Question
        admin.site.register(Question)
        ````

